---
layout: page
title: 2015年度小知识点和技巧笔记
categories: [笔记]
tags: [2015,技巧,个人,前端]
---

>2015年虽然已经过去3个半月，但是想了又想还是觉得有必要把这篇笔记写一下。知识点比较多，就不按时间来咯。

>### 1. 随机取色
{%highlight js%}
  return '#'+(Math.random()*0xffffff<<0).toString(16);
{%endhighlight%}

>##### 扩展
>字符串解析模版
{%highlight js%}
  [].forEach.call($$("*"),function(a){
    a.style.outline="1px solid #"+(~~(Math.random()*(1<<24))).toString(16);
  });
{%endhighlight%}

>### 2.histrory.pushState 无刷新修改地址栏显示地址的方法
>需求：Ajax局部刷新是小菜一碟。但现在每次ajax请求后，在不刷新页面的情况下改变url地址。

>##### 限制
>1.传递的url必须域名相同，不能跨域
>2.state对象虽然可以存储很多自定义的属性，但对于不可序列化的对象则不能存储，如：DOM对象。

{%highlight js%}
  var stateObj = { foo: "bar" };
  history.pushState(stateObj, "page 2", "list.html");
{%endhighlight%}
>比如我现在的页面的url是：http://yi-love.github.io/blog/,我的目标是要让点击Github之后：https://github.com/Yi-love，
>然后点击返回回退到 ： http://yi-love.github.io/blog/list.html 这个页面。

>所以通过ajax我们可以每次都pushState一个json对象。这样就会让用户点击回退的时候可以回退到他之前查询过的页面，而不是一个新的页面。

>##### 其它相关连参数

>1.history.replaceState: 操作类似于history.pushState()，不同之处在于replaceState()方法会修改当前历史记录条目而并非创建新的条目。

>2.window.onpopstate: 是popstate事件在window对象上的事件句柄.每当处于激活状态的历史记录条目发生变化时,popstate事件就会在对应window对象上触发. 

{%highlight js%}
  history.replaceState();
  window.onpopstate = funcg;
{%endhighlight%}
>##### 参考资料
>[histrory.pushState][pushState]

>[window.onpopstate][onpopstate]

[pushState]:https://developer.mozilla.org/zh-CN/docs/DOM/Manipulating_the_browser_history
[onpopstate]: https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onpopstate

>### 3.Promise图片预加载
>思想：通过Promise异步加载图片。
{%highlight js%}
  (function (global) {
  'use strict';
  //主要的加载器Promise
  function defer() {
    var resolve, reject, 
      promise = new Promise(function (a, b) {
      resolve = a;
      reject = b;
    });
    return {
      resolve: resolve,//成功
      reject: reject,//失败
      promise: promise//promise对象
    };
  }
  /**
   * 图片预加载 ImagePreloader
   */
  var ImagePreloader = function (options) {
    this.options = options || {};
    this.options.parallel = this.options.parallel || false;
    this.items = [];
    this.max = 0;
  };

  /**
   * 图片加载队列
   */
  ImagePreloader.prototype.queue = function (array) {
    if (!Array.isArray(array)) {
      array = [array];
    }
    if (array.length > this.max) {
      this.max = array.length;
    }
    var deferred = defer();
    this.items.push({
      collection: array,
      deferred: deferred
    });
    return deferred.promise;
  };

  /**
   * 处理加载成功和失败的图片 preloadImage
   */
  ImagePreloader.prototype.preloadImage = function (path) {
    return new Promise(function (resolve, reject) {
      var image = new Image();
      image.onload = resolve;
      image.onerror = resolve;
      image.src = path;
    });
  };

  /**
   * 加载图片
   */
  ImagePreloader.prototype.preload = function () {
    var deck, decks = [];
    if (this.options.parallel) {
      for (var i = 0; i < this.max; i++) {
        this.items.forEach(function (item) {
          if (typeof item.collection[i] !== 'undefined') {
            item.collection[i] = this.preloadImage(item.collection[i]);
          }
        }, this);
      }
    } else {
      this.items.forEach(function (item) {
        item.collection = item.collection.map(this.preloadImage);
      }, this);
    }
    this.items.forEach(function (item) {
      deck = Promise.all(item.collection)//请求图片
        .then(item.deferred.resolve.bind(item.deferred))
        .catch(console.log.bind(console));
      decks.push(deck);
    });
    return Promise.all(decks);
  };
  global.ImagePreloader = ImagePreloader;
}(window));
{%endhighlight%}
>例子：
{%highlight js%}
  function Deck(node, preloader, index) {
    var data = JSON.parse(node.getAttribute('data-images'));
    preloader.queue(data)
      .then(function () {
        console.log('Deck ' + index + ' loaded.');
        node.classList.add('loaded');
      })
      .catch(console.error.bind(console));
  }
  document.addEventListener('DOMContentLoaded', function () {
	var ip = new ImagePreloader({
	  parallel: false
	});
	var decks = Array.prototype.slice.call(document.querySelectorAll('.deck'));
	decks.forEach(function (deck, index) {
	  new Deck(deck, ip, index);
	});
	ip.preload()
	 .then(function () {
	  console.log('All decks loaded.');
	});
  });
{%endhighlight%}

>### 4.页面性能测试
>[http://www.webpagetest.org/][webpagetest]

[webpagetest]: http://www.webpagetest.org/
