---
layout: page
title: zepto.jsv1.0 源码解读-01
categories: [JavaScript]
tags: [前端开发,zepto , 源码 , dom ]
---

>一直以来都有一个问题困扰着我，那就是我什么时候才能写出一个好用的html的dom元素选择器。
>假如就只是单单把 document.getElementById || document.getElementByTagName ...
>封装起来的话，没有多大的意义。可用的扩展功能较少，没有zepto，Jquery灵活。
>为了一探究竟，我就从网上下载了zepto源码下来研究。
>我一看这就一个js文件，看样子要去github上确认一下。于是使用命令
{% highlight sh %}
 	git clone https://github.com/madrobby/zepto.git
{% endhighlight %}
>克隆了一份到本地，打开一看原来zepto本来是有很多个模块组成的。

>#### zepto常用模块 ####

>1.   zepto.js   这个是核心模块
>2.   ajax.js    xhr模块
>3.   event.js   事件模块
>4.   form.js    表单验证
>5.   touch.js   移动端事件

>做过移动端页面的同学应该对它都不会陌生。我记得好像淘宝的商品详情页好像就是缩水版的zepto,也就是只包含了部分模块。
>感兴趣可以去看看。

>今天就来分析zepto的选择器源码是如何实现的吧。

#### zepto.js模块 ####
>那么这么多函数，从何下手呢。咱们就从用的最多的  $ 下手。
>纵观全局,先分析  $ 是怎么来的。
{% highlight js %}
	var Zepto = (function() {
		...... //省略代码
		zepto.Z.prototype = Z.prototype = $.fn
		zepto.uniq = uniq
		zepto.deserializeValue = deserializeValue
		$.zepto = zepto
		
		return $ // $ 这个就是zepto暴露到全局的唯一对象 
	})()
	window.Zepto = Zepto
	window.$ === undefined && (window.$ = Zepto)
{%endhighlight%}
>会发现整个Zepto其实是一个闭包的自动执行函数,对外界暴露的唯一的就是 $,就是那一条*return $*.

>假如window对象的 $ 没有被占用就将 Zepto赋值到window对象的$上。

>不管我们在js 里面通过$(serlector [,context]) 还是 Zepto(selector[,context])进行调用，都会调用Zepto内部的$.

#### Zepto内部的$ ####
>现在我们进如Zepto内部,看一下$是一个什么对象。
{% highlight js %}
	$ = function(selector, context){
	    return zepto.init(selector, context)
	}
{%endhighlight%}

>原来Zepto内部还有一个zepto对象(首字母小写),现在终于明朗了。$其实是对zepto.init函数的封装。
>也就是说 $(serlector [,context]) || Zepto(selector[,context]) ,其实就是执行的zepto.init函数。
下面我们进入zepto.init函数去看看 ,为了看清楚我这里特意截取图片。
![zepto.init函数]({{site.baseurl}}/images/2015/1107_03.jpg)

>下面是我对这个函数的流程简化图。
![zepto.init函数简化]({{site.baseurl}}/images/2015/1107_02.jpg)
>再来一张对比图,看不清自行拉到新窗口看。
![zepto.init函数简化]({{site.baseurl}}/images/2015/1107_01.jpg)

>可以知道zepto.init函数将情况分为了 5种

>1.   selector 为空 及什么都不做，返回空集合
>2.   selector 是字符串
>3.   selector 是函数
>4.   selector 是zepto集合
>5.   其他

>不管是哪一种情况返回的都是zepto集合,也就是说都会执行一次zepto.Z([dom,selector])函数，或原来执行过一次。这样返回的数据将是统一的格式。
>下面我们就在第一种情况中讨论zepto.Z函数。

#### 1.selector 为空 ####
>selector为空，是直接执行 zepto.Z() , 并返回。
{% highlight js %}
	function Z(dom, selector) {
	    var i, len = dom ? dom.length : 0
	    for (i = 0; i < len; i++) this[i] = dom[i]
	    this.length = len
	    this.selector = selector || ''
	}
	zepto.Z = function(dom, selector) {
	    return new Z(dom, selector) //新建对象 ，防止使用同一个对象产生错误，使用new
	}
{%endhighlight%}
>这个函数其实就是对获取到的dom元素等做一下格式化，假如dom是存在的那就将所有的都赋值到this对象上。

>为空，那么最后得到的就是一个空的对象 : [] , 命令格式： $()。

#### 2.selector为字符串 ####
>这中情况下又分了3中情况：

>1.   传人的是html
>2.   context不为空,在指定的域中查找
>3.   调用选择器在*document*中查找

>不管是哪一种情况，对字符串进行前后多余空格删除是必须的。

>##### 2.1传入的是html #####

>e.g: $('<div>传人html</div>')

>zepto会认为这样做的目的是生成dom元素。那么这样的操作其实等价于：
{% highlight js %}
	//$('<div>传人html</div>')
	var div = document.createElement('div')
	div.innerHTML = "传人html"
	return div
{%endhighlight%}

>这只是一个最简单的列子，如果要作为一个灵活的功能模块的话，还需要进一步的优化和扩展，比如如何判断传人的是html标签.
>我们知道html标签就只有两种情况
>\<tag/>  或  \<tag></tag>，那么传人的html可能就是这两种情况的互相嵌套。

>那么就可以通过正则表达式匹配出入的是否符合html标签标准
{% highlight js %}
	// html标签判断
    fragmentRE = /^\s*<(\w+|!)[^>]*>/
{%endhighlight%}
>上面这个正则表达式的意思是：
{% highlight js %}
	// html标签判断
    ^\s*  : 表示从行首匹配 0-n次的空白符
    <(\w+|!)[^>]*> : 表示匹配以 < 开头和>结尾的字符串，并且必须匹配一个可以组成单词的字符或!开头，不匹配> 0-n次
{%endhighlight%}
>你可能会发现为什么没有匹配\</tag>,其实没有必要了,因为只要匹配出它是标签即可创建了。而且zepto也只匹配了最外层的tag，并没有匹配所有的这是为什么。
{% highlight js %}
	// html标签判断
	if (selector[0] == '<' && /^\s*<(\w+|!)[^>]*>/.test(selector)){
		dom = zepto.fragment(selector, RegExp.$1, context), selector = null
	}
    // RegExp.$1  等价于  匹配到的tag  
    // e.g: $('<img>')   --> RegExp.$1 == img 
{%endhighlight%}
>zepto交给了zepto.fragment()去处理，也就是说上面的js只要保证最少有一个\<tag>即可。
![zepto.fragment函数]({{site.baseurl}}/images/2015/1107_04.jpg)

>函数的注释也说得很明白：根据html字符串和标签名生成dom节点数组并返回。
>这个函数也是可以被重写的，并且这个函数不完全兼容浏览器。


>未完待续......



































































