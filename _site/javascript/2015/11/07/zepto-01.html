<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
	<meta charset="UTF-8">
<meta name="apple-mobile-web-app-title" content="zepto.jsv1.0 源码解读-01">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-touch-fullscreen" content="yes">
<meta http-equiv="Cache-Control" content="no-siteapp">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="format-detection" content="telephone=no">
<meta name="format-detection" content="email=no">
<meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
<link rel="stylesheet" href="/blog/stylesheets/normalize.css">
<link rel="stylesheet" href="/blog/stylesheets/base.css">
<link rel="stylesheet" href="/blog/stylesheets/syntax.css">
<script src="/blog/javascripts/base.js"></script>
<title>zepto.jsv1.0 源码解读-01</title>
</head>
<body>
	<div class="j-container-fluid j-header">
	<div class="j-row">
		<div class="j-container">
			<h1 class="j-logo"><a href="/blog/"><img src="/blog/images/logo.png" /> </a></h1>
			<nav class="j-row j-nav">
				<a href="/blog/">首页</a>
				<a href="/blog/list.html">归档</a>
				<a href="https://github.com/Yi-love">Github</a>
				<a href="/blog/me.html">Me</a>
			</nav>
		</div>
	</div>
</div>
	<div class="j-container">
		<div class="j-row">
			<div class="j-col-xs-12 j-col-sm-12 j-col-md-9">
				<div class="j-container j-content">
					<h2 class="j-i-title"><a href="/blog/javascript/2015/11/07/zepto-01.html">zepto.jsv1.0 源码解读-01</a></h2>
						<p class="j-i-time">07 Nov 2015</p>
						<p class="j-i-tags">
							
							<span class="j-i-tag">前端开发</span>
							
							<span class="j-i-tag">zepto</span>
							
							<span class="j-i-tag">源码</span>
							
							<span class="j-i-tag">dom</span>
							
						</p>
						<div class="j-container">
							<div class="j-row j-artclie-txt"><blockquote>
  <p>一直以来都有一个问题困扰着我，那就是我什么时候才能写出一个好用的html的dom元素选择器。
假如就只是单单把 document.getElementById || document.getElementByTagName …
封装起来的话，没有多大的意义。可用的扩展功能较少，没有zepto，Jquery灵活。
为了一探究竟，我就从网上下载了zepto源码下来研究。
我一看这就一个js文件，看样子要去github上确认一下。于是使用命令</p>
</blockquote>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"> 	git clone https://github.com/madrobby/zepto.git</code></pre></figure>

<blockquote>
  <p>克隆了一份到本地，打开一看原来zepto本来是有很多个模块组成的。</p>
</blockquote>

<blockquote>
  <h4 id="zepto">zepto常用模块</h4>
</blockquote>

<blockquote>
  <ol>
    <li>zepto.js   这个是核心模块</li>
    <li>ajax.js    xhr模块</li>
    <li>event.js   事件模块</li>
    <li>form.js    表单验证</li>
    <li>touch.js   移动端事件</li>
  </ol>
</blockquote>

<blockquote>
  <p>做过移动端页面的同学应该对它都不会陌生。我记得好像淘宝的商品详情页好像就是缩水版的zepto,也就是只包含了部分模块。
感兴趣可以去看看。</p>
</blockquote>

<blockquote>
  <p>今天就来分析zepto的选择器源码是如何实现的吧。</p>
</blockquote>

<h4 id="zeptojs">zepto.js模块</h4>
<blockquote>
  <p>那么这么多函数，从何下手呢。咱们就从用的最多的  $ 下手。
纵观全局,先分析  $ 是怎么来的。</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">	<span class="kd">var</span> <span class="nx">Zepto</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
		<span class="p">......</span> <span class="c1">//省略代码</span>
		<span class="nx">zepto</span><span class="p">.</span><span class="nx">Z</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">Z</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">fn</span>
		<span class="nx">zepto</span><span class="p">.</span><span class="nx">uniq</span> <span class="o">=</span> <span class="nx">uniq</span>
		<span class="nx">zepto</span><span class="p">.</span><span class="nx">deserializeValue</span> <span class="o">=</span> <span class="nx">deserializeValue</span>
		<span class="nx">$</span><span class="p">.</span><span class="nx">zepto</span> <span class="o">=</span> <span class="nx">zepto</span>
		
		<span class="k">return</span> <span class="nx">$</span> <span class="c1">// $ 这个就是zepto暴露到全局的唯一对象 </span>
	<span class="p">})()</span>
	<span class="nb">window</span><span class="p">.</span><span class="nx">Zepto</span> <span class="o">=</span> <span class="nx">Zepto</span>
	<span class="nb">window</span><span class="p">.</span><span class="nx">$</span> <span class="o">===</span> <span class="kc">undefined</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">$</span> <span class="o">=</span> <span class="nx">Zepto</span><span class="p">)</span></code></pre></figure>

<blockquote>
  <p>会发现整个Zepto其实是一个闭包的自动执行函数,对外界暴露的唯一的就是 $,就是那一条<em>return $</em>.</p>
</blockquote>

<blockquote>
  <p>假如window对象的 $ 没有被占用就将 Zepto赋值到window对象的$上。</p>
</blockquote>

<blockquote>
  <p>不管我们在js 里面通过$(serlector [,context]) 还是 Zepto(selector[,context])进行调用，都会调用Zepto内部的$.</p>
</blockquote>

<h4 id="zepto-1">Zepto内部的$</h4>
<blockquote>
  <p>现在我们进如Zepto内部,看一下$是一个什么对象。</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">	<span class="nx">$</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">selector</span><span class="p">,</span> <span class="nx">context</span><span class="p">){</span>
	    <span class="k">return</span> <span class="nx">zepto</span><span class="p">.</span><span class="nx">init</span><span class="p">(</span><span class="nx">selector</span><span class="p">,</span> <span class="nx">context</span><span class="p">)</span>
	<span class="p">}</span></code></pre></figure>

<blockquote>
  <p>原来Zepto内部还有一个zepto对象(首字母小写),现在终于明朗了。$其实是对zepto.init函数的封装。
也就是说 $(serlector [,context]) || Zepto(selector[,context]) ,其实就是执行的zepto.init函数。
下面我们进入zepto.init函数去看看 ,为了看清楚我这里特意截取图片。
<img src="/blog/images/2015/1107_03.jpg" alt="zepto.init函数" /></p>
</blockquote>

<blockquote>
  <p>下面是我对这个函数的流程简化图。
<img src="/blog/images/2015/1107_02.jpg" alt="zepto.init函数简化" />
再来一张对比图,看不清自行拉到新窗口看。
<img src="/blog/images/2015/1107_01.jpg" alt="zepto.init函数简化" /></p>
</blockquote>

<blockquote>
  <p>可以知道zepto.init函数将情况分为了 5种</p>
</blockquote>

<blockquote>
  <ol>
    <li>selector 为空 及什么都不做，返回空集合</li>
    <li>selector 是字符串</li>
    <li>selector 是函数</li>
    <li>selector 是zepto集合</li>
    <li>其他</li>
  </ol>
</blockquote>

<blockquote>
  <p>不管是哪一种情况返回的都是zepto集合,也就是说都会执行一次zepto.Z([dom,selector])函数，或原来执行过一次。这样返回的数据将是统一的格式。
下面我们就在第一种情况中讨论zepto.Z函数。</p>
</blockquote>

<h4 id="selector-">1.selector 为空</h4>
<blockquote>
  <p>selector为空，是直接执行 zepto.Z() , 并返回。</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">	<span class="kd">function</span> <span class="nx">Z</span><span class="p">(</span><span class="nx">dom</span><span class="p">,</span> <span class="nx">selector</span><span class="p">)</span> <span class="p">{</span>
	    <span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">dom</span> <span class="p">?</span> <span class="nx">dom</span><span class="p">.</span><span class="nx">length</span> <span class="p">:</span> <span class="mi">0</span>
	    <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="k">this</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">dom</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	    <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">len</span>
	    <span class="k">this</span><span class="p">.</span><span class="nx">selector</span> <span class="o">=</span> <span class="nx">selector</span> <span class="o">||</span> <span class="s1">''</span>
	<span class="p">}</span>
	<span class="nx">zepto</span><span class="p">.</span><span class="nx">Z</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">dom</span><span class="p">,</span> <span class="nx">selector</span><span class="p">)</span> <span class="p">{</span>
	    <span class="k">return</span> <span class="k">new</span> <span class="nx">Z</span><span class="p">(</span><span class="nx">dom</span><span class="p">,</span> <span class="nx">selector</span><span class="p">)</span> <span class="c1">//新建对象 ，防止使用同一个对象产生错误，使用new</span>
	<span class="p">}</span></code></pre></figure>

<blockquote>
  <p>这个函数其实就是对获取到的dom元素等做一下格式化，假如dom是存在的那就将所有的都赋值到this对象上。</p>
</blockquote>

<blockquote>
  <p>为空，那么最后得到的就是一个空的对象 : [] , 命令格式： $()。</p>
</blockquote>

<h4 id="selector">2.selector为字符串</h4>
<blockquote>
  <p>这中情况下又分了3中情况：</p>
</blockquote>

<blockquote>
  <ol>
    <li>传人的是html</li>
    <li>context不为空,在指定的域中查找</li>
    <li>调用选择器在<em>document</em>中查找</li>
  </ol>
</blockquote>

<blockquote>
  <p>不管是哪一种情况，对字符串进行前后多余空格删除是必须的。</p>
</blockquote>

<blockquote>
  <h5 id="html">2.1传入的是html</h5>
</blockquote>

<blockquote>
  <p>e.g: $(‘&lt;div&gt;传人html&lt;/div&gt;’)</p>
</blockquote>

<blockquote>
  <p>zepto会认为这样做的目的是生成dom元素。那么这样的操作其实等价于：</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">	<span class="c1">//$('&lt;div&gt;传人html&lt;/div&gt;')</span>
	<span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">'div'</span><span class="p">)</span>
	<span class="nx">div</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="s2">"传人html"</span>
	<span class="k">return</span> <span class="nx">div</span></code></pre></figure>

<blockquote>
  <p>这只是一个最简单的列子，如果要作为一个灵活的功能模块的话，还需要进一步的优化和扩展，比如如何判断传人的是html标签.
我们知道html标签就只有两种情况
&lt;tag/&gt;  或  &lt;tag&gt;&lt;/tag&gt;，那么传人的html可能就是这两种情况的互相嵌套。</p>
</blockquote>

<blockquote>
  <p>那么就可以通过正则表达式匹配出入的是否符合html标签标准</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">	<span class="c1">// html标签判断</span>
    <span class="nx">fragmentRE</span> <span class="o">=</span> <span class="sr">/^</span><span class="se">\s</span><span class="sr">*&lt;</span><span class="se">(\w</span><span class="sr">+|!</span><span class="se">)[^</span><span class="sr">&gt;</span><span class="se">]</span><span class="sr">*&gt;/</span></code></pre></figure>

<blockquote>
  <p>上面这个正则表达式的意思是：</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">	<span class="c1">// html标签判断</span>
    <span class="o">^</span><span class="err">\</span><span class="nx">s</span><span class="o">*</span>  <span class="err">:</span> <span class="err">表示从行首匹配</span> <span class="mi">0</span><span class="o">-</span><span class="nx">n</span><span class="err">次的空白符</span>
    <span class="o">&lt;</span><span class="p">(</span><span class="err">\</span><span class="nx">w</span><span class="o">+|!</span><span class="p">)[</span><span class="o">^&gt;</span><span class="p">]</span><span class="o">*&gt;</span> <span class="err">:</span> <span class="err">表示匹配以</span> <span class="o">&lt;</span> <span class="err">开头和</span><span class="o">&gt;</span><span class="err">结尾的字符串，并且必须匹配一个可以组成单词的字符或</span><span class="o">!</span><span class="err">开头，不匹配</span><span class="o">&gt;</span> <span class="mi">0</span><span class="o">-</span><span class="nx">n</span><span class="err">次</span></code></pre></figure>

<blockquote>
  <p>你可能会发现为什么没有匹配&lt;/tag&gt;,其实没有必要了,因为只要匹配出它是标签即可创建了。而且zepto也只匹配了最外层的tag，并没有匹配所有的这是为什么。</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">	<span class="c1">// html标签判断</span>
	<span class="k">if</span> <span class="p">(</span><span class="nx">selector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'&lt;'</span> <span class="o">&amp;&amp;</span> <span class="sr">/^</span><span class="se">\s</span><span class="sr">*&lt;</span><span class="se">(\w</span><span class="sr">+|!</span><span class="se">)[^</span><span class="sr">&gt;</span><span class="se">]</span><span class="sr">*&gt;/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">selector</span><span class="p">)){</span>
		<span class="nx">dom</span> <span class="o">=</span> <span class="nx">zepto</span><span class="p">.</span><span class="nx">fragment</span><span class="p">(</span><span class="nx">selector</span><span class="p">,</span> <span class="nb">RegExp</span><span class="p">.</span><span class="nx">$1</span><span class="p">,</span> <span class="nx">context</span><span class="p">),</span> <span class="nx">selector</span> <span class="o">=</span> <span class="kc">null</span>
	<span class="p">}</span>
    <span class="c1">// RegExp.$1  等价于  匹配到的tag  </span>
    <span class="c1">// e.g: $('&lt;img&gt;')   --&gt; RegExp.$1 == img </span></code></pre></figure>

<blockquote>
  <p>zepto交给了zepto.fragment()去处理，也就是说上面的js只要保证最少有一个&lt;tag&gt;即可。
<img src="/blog/images/2015/1107_04.jpg" alt="zepto.fragment函数" /></p>
</blockquote>

<blockquote>
  <p>函数的注释也说得很明白：根据html字符串和标签名生成dom节点数组并返回。
这个函数也是可以被重写的，并且这个函数不完全兼容浏览器。</p>
</blockquote>

</div>
						</div>
				</div>
			</div>
			<div class="j-col-xs-12 j-col-sm-12 j-col-md-3">
	<div class="j-user">
		<div class="j-user-thumb">
			<a href=""><img src="/blog/images/user.jpg" alt="" /></a>
		</div>
		<div class="j-user-info">
			<a href="">微信</a>
			<a href="">微博</a>
			<a href="">QQ</a>
		</div>
	</div>
	<div class="j-class-list">
		<h3 class="j-row">分类</h3>
		
		<a href="/blog/category.html?category=笔记">笔记 <span class="j-class-i-num">(4)</span></a>
		
		<a href="/blog/category.html?category=JavaScript">JavaScript <span class="j-class-i-num">(1)</span></a>
		
	</div>
</div>
		</div>
	</div>
	<div class="j-container-fluid j-footer">
	<div class="j-container">
		<p class="j-footer-say">喜欢一个人需要理由吗？需要吗？不需要吗？需要吗？……</p>
		<p class="j-footer-say j-tlgr">——周星驰 《大话西游》</p>
	</div>
</div>

</body>
</html>