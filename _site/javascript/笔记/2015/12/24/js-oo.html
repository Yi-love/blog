<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
	<meta charset="UTF-8">
<meta name="apple-mobile-web-app-title" content="JavaScript面向对象设计之对象创建与继承">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-touch-fullscreen" content="yes">
<meta http-equiv="Cache-Control" content="no-siteapp">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="format-detection" content="telephone=no">
<meta name="format-detection" content="email=no">
<meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
<link rel="stylesheet" href="/blog/stylesheets/normalize.css">
<link rel="stylesheet" href="/blog/stylesheets/base.css">
<link rel="stylesheet" href="/blog/stylesheets/monokai.css">
<script src="/blog/javascripts/base.js"></script>
<title>JavaScript面向对象设计之对象创建与继承</title>
</head>
<body>
	<div class="j-container-fluid j-header">
	<div class="j-row">
		<div class="j-container">
			<h1 class="j-logo"><a href="/blog/"><img src="/blog/images/logo.png" /> </a></h1>
			<nav class="j-row j-nav">
				<a href="/blog/">首页</a>
				<a href="/blog/list.html">归档</a>
				<a href="https://github.com/Yi-love">Github</a>
				<a href="/blog/me.html">Me</a>
			</nav>
		</div>
	</div>
</div>
	<div class="j-container">
		<div class="j-row">
			<div class="j-col-xs-12 j-col-sm-12 j-col-md-9">
				<div class="j-container j-content">
					<h2 class="j-i-title"><a href="/blog/javascript/%E7%AC%94%E8%AE%B0/2015/12/24/js-oo.html" title="JavaScript面向对象设计之对象创建与继承">JavaScript面向对象设计之对象创建与继承</a></h2>
						<p class="j-i-time">24 Dec 2015</p>
						<p class="j-i-tags">
							
							<span class="j-i-tag">面向对象</span>
							
							<span class="j-i-tag">js</span>
							
							<span class="j-i-tag">继承</span>
							
						</p>
						<div class="j-container">
							<div class="j-row j-artclie-txt"><blockquote>
  <p>面向对象(Object-Oriendted OO)语言的一个标准，那就是他们都有类的概念。
但javaScript是没有类的，因此它的对象定义为“无序属性的集合，其属性可以包含基本值,对象或函数”。</p>
</blockquote>

<blockquote>
  <h4 id="section">对象的创建方式</h4>
  <p>1.通过 new Object()创建：</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">  <span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span></code></pre></figure>

<blockquote>
  <p>2.使用 {}：</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">  <span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{};</span></code></pre></figure>

<blockquote>
  <p>虽然Object构造函数和对象字面量都可以创建对象，但都有明显的缺点：使用同一个接口创建很多对象，会产生大量重复代码。
为了解决上面的问题，开始有了模式用来创建对象。</p>
</blockquote>

<blockquote>
  <h3 id="section-1">创建对象</h3>
</blockquote>

<blockquote>
  <h4 id="section-2">1.工厂模式</h4>
  <p>工厂模式是软件工厂领域里最广为人知的一种设计模式。</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">  <span class="kd">function</span> <span class="nx">createPerson</span><span class="p">(</span><span class="nx">name</span> <span class="p">,</span> <span class="nx">age</span> <span class="p">,</span> <span class="nx">job</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">job</span> <span class="o">=</span> <span class="nx">job</span><span class="p">;</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="k">return</span> <span class="nx">o</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="nx">createPerson</span><span class="p">(</span><span class="s1">'jin'</span> <span class="p">,</span> <span class="mi">24</span> <span class="p">,</span> <span class="s1">'ue'</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">person2</span> <span class="o">=</span> <span class="nx">createPerson</span><span class="p">(</span><span class="s1">'soul'</span> <span class="p">,</span> <span class="mi">24</span> <span class="p">,</span> <span class="s1">'php'</span><span class="p">);</span></code></pre></figure>

<blockquote>
  <p>上面的代码展示了最基本的工厂模式的特点。函数createPerson()就好比一个工厂，参数 [name , age , job]好比是零件，
通过工厂内的 o 处理，生成了多个相似的产品。</p>
</blockquote>

<blockquote>
  <p>总结： 工厂模式可以解决创建多个相似对象的问题，但不能解决对象识别(都是Object对象)。</p>
</blockquote>

<blockquote>
  <h4 id="section-3">2.构造函数模式</h4>
  <p>构造函数可以用来创建特定类型的对象。</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">  <span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span> <span class="p">,</span> <span class="nx">age</span> <span class="p">,</span> <span class="nx">job</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">job</span> <span class="o">=</span> <span class="nx">job</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
    <span class="p">};</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s1">'jin'</span> <span class="p">,</span> <span class="mi">24</span> <span class="p">,</span> <span class="s1">'ue'</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">person2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s1">'soul'</span> <span class="p">,</span> <span class="mi">24</span> <span class="p">,</span> <span class="s1">'php'</span><span class="p">);</span></code></pre></figure>

<blockquote>
  <p>创建Person实例必须使用new。创建实例的步骤主要有4步：</p>
</blockquote>

<blockquote>
  <ol>
    <li>创建一个新对象</li>
    <li>将构造函数的作用域赋给新对象(this会指向新对象)</li>
    <li>执行构造函数的代码</li>
    <li>返回新对象</li>
  </ol>
</blockquote>

<blockquote>
  <p>总结：创建自定义的构造函数可以将它的实例标识为一种特定的类型。但每个方法都要在每个实例中创建一次。</p>
</blockquote>

<blockquote>
  <h4 id="section-4">3.原型模式</h4>
  <p>我们创建的每一个函数都有一个<em>propotype</em>(原型)属性,这个属性是一个指针，指向一个对象,这个对象包含可以由特定类型的所有实例
共享的属性和方法。</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">  <span class="kd">function</span> <span class="nx">Person</span><span class="p">(){</span>
  <span class="p">}</span>
  <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s1">'Jin'</span><span class="p">;</span>
  <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>
  <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">job</span> <span class="o">=</span> <span class="s1">'ue'</span><span class="p">;</span>
  <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  	<span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">();</span>
  <span class="kd">var</span> <span class="nx">person2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">();</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person1</span><span class="p">.</span><span class="nx">getName</span> <span class="o">==</span> <span class="nx">person2</span><span class="p">.</span><span class="nx">getName</span><span class="p">())</span><span class="c1">//true</span></code></pre></figure>

<blockquote>
  <p>要点：实例内部包含着一个指针指向构造函数的原型对象，这个连接是存在于实例与构造函数的原型对象之间，而非实例与构造函数之间。
实例中没有包含属性和函数，但还是可以调用person1.getName()。就是因为这个指针。不过这个过程会调用2次，一次是person1内部，第二次是
原型对象的getName()。</p>
</blockquote>

<blockquote>
  <p>屏蔽原型属性和函数的做法：</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">  <span class="c1">//覆盖原型对象的属性</span>
  <span class="nx">person1</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s1">'yi'</span><span class="p">;</span></code></pre></figure>

<blockquote>
  <p>重新访问原型对象的属性:</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">  <span class="c1">//删除实例中的属性</span>
  <span class="k">delete</span> <span class="nx">person1</span><span class="p">.</span><span class="nx">name</span></code></pre></figure>

<blockquote>
  <p>判断属性是在实例中还是在原型对象中：</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">  <span class="c1">//判断属性是在实例中还是在原型对象中</span>
  <span class="nx">person1</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s1">'name'</span><span class="p">)</span> <span class="c1">//true  ： 实例中  | false : 原型对象中|| 不存在</span>
  <span class="c1">//判断属性在原型中  true: 在原型中</span>
  <span class="kd">function</span> <span class="nx">hasPrototypeProperty</span><span class="p">(</span><span class="nx">object</span> <span class="p">,</span> <span class="nx">name</span><span class="p">){</span>
    <span class="k">return</span> <span class="o">!</span><span class="nx">object</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">name</span> <span class="k">in</span> <span class="nx">object</span><span class="p">);</span>
  <span class="p">}</span></code></pre></figure>

<blockquote>
  <p>获取对象属性：</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js"> <span class="c1">//可枚举属性获取</span>
 <span class="kd">var</span> <span class="nx">keys</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">person1</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
 <span class="c1">//for in</span>
 <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">name</span> <span class="k">in</span> <span class="nx">person1</span><span class="p">){</span>
   <span class="nx">keys</span><span class="p">[</span><span class="nx">keys</span><span class="p">.</span><span class="nx">length</span><span class="p">]</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="nx">keys</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">','</span><span class="p">);</span>
 <span class="c1">//包含不可枚举属性获取</span>
 <span class="nx">keys</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getPropertyNames</span><span class="p">(</span><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span></code></pre></figure>

<blockquote>
  <p>待续。。。。。</p>
</blockquote>

</div>
						</div>
				</div>
			</div>
			<div class="j-col-xs-12 j-col-sm-12 j-col-md-3">
	<div class="j-user">
		<div class="j-user-thumb">
			<a href=""><img src="/blog/images/user.jpg" alt="" /></a>
		</div>
		<div class="j-user-info">
			<a href="">微信</a>
			<a href="">微博</a>
			<a href="">QQ</a>
		</div>
	</div>
	<div class="j-class-list">
		<h3 class="j-row">分类</h3>
		
		<a href="/blog/category.html?category=笔记">笔记 <span class="j-class-i-num">(5)</span></a>
		
		<a href="/blog/category.html?category=JavaScript">JavaScript <span class="j-class-i-num">(5)</span></a>
		
		<a href="/blog/category.html?category=bee.js">bee.js <span class="j-class-i-num">(1)</span></a>
		
	</div>
</div>
		</div>
	</div>
	<div class="j-container-fluid j-footer">
	<div class="j-container">
		<p class="j-footer-say">喜欢一个人需要理由吗？需要吗？不需要吗？需要吗？……</p>
		<p class="j-footer-say j-tlgr">——周星驰 《大话西游》</p>
	</div>
</div>

</body>
</html>