<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
	<meta charset="UTF-8">
<meta name="apple-mobile-web-app-title" content="JavaScript面向对象设计—对象继承">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-touch-fullscreen" content="yes">
<meta http-equiv="Cache-Control" content="no-siteapp">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="format-detection" content="telephone=no">
<meta name="format-detection" content="email=no">
<meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
<link rel="stylesheet" href="/blog/stylesheets/normalize.css">
<link rel="stylesheet" href="/blog/stylesheets/base.css">
<link rel="stylesheet" href="/blog/stylesheets/monokai.css">
<script src="/blog/javascripts/base.js"></script>
<title>JavaScript面向对象设计—对象继承</title>
</head>
<body>
	<div class="j-container-fluid j-header">
	<div class="j-row">
		<div class="j-container">
			<h1 class="j-logo"><a href="/blog/"><img src="/blog/images/logo.png" /> </a></h1>
			<nav class="j-row j-nav">
				<a href="/blog/">首页</a>
				<a href="/blog/list.html">归档</a>
				<a href="https://github.com/Yi-love">Github</a>
				<a href="/blog/me.html">Me</a>
			</nav>
		</div>
	</div>
</div>
	<div class="j-container">
		<div class="j-row">
			<div class="j-col-xs-12 j-col-sm-12 j-col-md-9">
				<div class="j-container j-content">
					<h2 class="j-i-title"><a href="javascript:void(0)" title="JavaScript面向对象设计—对象继承">JavaScript面向对象设计—对象继承</a></h2>
						<p class="j-i-time">24 Dec 2015</p>
						<p class="j-i-tags">
							
							<span class="j-i-tag">面向对象</span>
							
							<span class="j-i-tag">js</span>
							
							<span class="j-i-tag">继承</span>
							
						</p>
						<div class="j-container">
							<div class="j-row j-artclie-txt"><blockquote>
  <p>接着上一篇对象的创建，这一篇主要写javaScript的继承方式。
许多语言的继承分为2种：接口继承和实现继承。
js没有函数签名，所以无法使用接口继承。js的实现继承是依靠原型链实现的。</p>
</blockquote>

<blockquote>
  <h3 id="section">1.原型链继承</h3>
  <p>基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">  <span class="kd">function</span> <span class="nx">SuperType</span><span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">property</span> <span class="o">=</span> <span class="kc">true</span>
  <span class="p">}</span>
  <span class="nx">SuperType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getSuperValue</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">property</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">SubType</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">subproperty</span> <span class="o">=</span> <span class="kc">false</span>
  <span class="p">}</span>
  <span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SuperType</span><span class="p">()</span>
  <span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getSubTypeValue</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  	<span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">subproperty</span>
  <span class="p">}</span>  
  <span class="kd">var</span> <span class="nx">subtype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">()</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">subtype</span><span class="p">.</span><span class="nx">getSuperValue</span><span class="p">())</span> <span class="c1">//true</span></code></pre></figure>

<blockquote>
  <p>分析他们的关系：</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">  <span class="nx">SubType</span><span class="p">[</span><span class="nx">prototype</span><span class="p">]</span> <span class="o">----&gt;</span>
                         <span class="o">|---&gt;</span><span class="nx">SubType</span> <span class="nx">Prototype</span>
  <span class="nx">subtype</span><span class="p">[[</span><span class="nx">prototype</span><span class="p">]]</span><span class="o">---&gt;</span>  <span class="p">[[</span><span class="nx">prototype</span><span class="p">]]</span>
                                <span class="o">|</span>
                                <span class="o">|</span>
                                <span class="nx">v</span>
  <span class="nx">SuperType</span><span class="p">[</span><span class="nx">prototype</span><span class="p">]</span><span class="o">-------&gt;</span><span class="nx">SuperType</span> <span class="nx">Prototype</span>
        <span class="o">^</span>                   <span class="p">[</span><span class="nx">constructor</span><span class="p">]</span>
        <span class="o">|</span>                       <span class="o">|</span>
        <span class="o">------------------------|</span></code></pre></figure>

<blockquote>
  <p>SubType有一个原型对象SubType Prototype , 实例subtype也有一个指针指向原型对象SubType Prototype ；原型对象 SubType Prototype 又是
SuperType 的实例，所以又有一个指针指向 SuperType 的原型对象 SuperType Prototype , SuperType Prototype 的构造函数指针指向了SuperType.</p>
</blockquote>

<blockquote>
  <p>总结：所有的函数的默认原型都是Object实例，因此默认的原型都包含了一个内部指针，指向Object.prototype.
通过原型链实现继承时，不能用对象字面量创建原型方法，这样会重新原型链。
存在的问题：引用类型值的原型属性会被所有实例所共享；创建子类型的实例时，不能向超类型的构造函数传递参数。</p>
</blockquote>

<blockquote>
  <h3 id="section-1">2.借用构造函数</h3>
  <p>基本思想：在子类构造函数的内部调用超类的构造函数。通过 apply() 和  call()实现。
两者的格式和参数定义：</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">  <span class="nx">call</span><span class="p">(</span> <span class="nx">thisArg</span> <span class="p">[,</span><span class="nx">arg1</span><span class="p">,</span><span class="nx">arg2</span><span class="p">,</span><span class="err">…</span> <span class="p">]</span> <span class="p">)</span><span class="c1">// 参数列表，arg1，arg2，...</span>
  <span class="nx">apply</span><span class="p">(</span><span class="nx">thisArg</span> <span class="p">[,</span><span class="nx">argArray</span><span class="p">]</span> <span class="p">)</span><span class="c1">// 参数数组，argArray</span></code></pre></figure>

<blockquote>
  <p>上面两个函数内部的this指针，都会被赋值为thisArg，这可实现将函数作为另外一个对象的方法运行的目的.</p>
</blockquote>

<blockquote>
  <p>案例：</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">  <span class="kd">function</span> <span class="nx">SuperType</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'red'</span><span class="p">,</span><span class="s1">'blue'</span><span class="p">,</span><span class="s1">'green'</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">SubType</span><span class="p">(){</span>
    <span class="nx">SuerType</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">subtype1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">()</span>
  <span class="nx">subtype1</span><span class="p">.</span><span class="nx">colors</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">'black'</span><span class="p">)</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">subtype1</span><span class="p">.</span><span class="nx">colors</span><span class="p">)</span> <span class="c1">// 'red,blue,green,black'</span>
  
  <span class="kd">var</span> <span class="nx">subtype2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">()</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">subtype2</span><span class="p">.</span><span class="nx">colors</span><span class="p">)</span> <span class="c1">// 'red,blue,green' </span></code></pre></figure>

<blockquote>
  <h4 id="section-2">2.1 传递参数</h4>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">  <span class="kd">function</span> <span class="nx">SuperType</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">SubType</span><span class="p">(){</span>
    <span class="nx">SuerType</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span> <span class="p">,</span><span class="s1">'Jin'</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">24</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">subtype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">()</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">subtype</span><span class="p">.</span><span class="nx">name</span> <span class="p">,</span><span class="nx">subtype</span><span class="p">.</span><span class="nx">age</span><span class="p">)</span> <span class="c1">// 'Jin',24</span></code></pre></figure>

<blockquote>
  <p>总结：相对于原型链而言，借用构造函数最大的优势在于，子类构造函数可以向超类构造函数中传递参数；
不足：方法都必须在构造函数中定义，函数无法复用；超类中定义的方法对于子类型而已不可见，所有的子类型都只能使用构造函数模式。</p>
</blockquote>

<blockquote>
  <h3 id="section-3">3.组合继承</h3>
  <p>指的是将原型链和借用构造函数组合到一起，发挥二者之长的继承。
基本思想：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">  <span class="kd">function</span> <span class="nx">SuperType</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'red'</span><span class="p">,</span><span class="s1">'blue'</span><span class="p">,</span><span class="s1">'green'</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="nx">SuperType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">SubType</span><span class="p">(</span><span class="nx">name</span> <span class="p">,</span> <span class="nx">age</span><span class="p">){</span>
    <span class="nx">SuperType</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="nx">name</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span>
  <span class="p">}</span>
  <span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SuperType</span><span class="p">()</span>
  <span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">SubType</span>
  <span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getAge</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">age</span>
  <span class="p">}</span>
  
  <span class="kd">var</span> <span class="nx">subtype1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">(</span><span class="s1">'Jin'</span><span class="p">,</span><span class="mi">24</span><span class="p">)</span>
  <span class="nx">subtype1</span><span class="p">.</span><span class="nx">colors</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">'black'</span><span class="p">)</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">subtype1</span><span class="p">.</span><span class="nx">colors</span><span class="p">)</span><span class="c1">//'red,blue,green,black'</span>
  <span class="nx">subtype1</span><span class="p">.</span><span class="nx">getName</span><span class="p">()</span> <span class="c1">//'Jin'</span>
  <span class="nx">subtype1</span><span class="p">.</span><span class="nx">getAge</span><span class="p">()</span> <span class="c1">//24</span>
  
  <span class="kd">var</span> <span class="nx">subtype2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">(</span><span class="s1">'Soul'</span><span class="p">,</span><span class="mi">24</span><span class="p">)</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">subtype2</span><span class="p">.</span><span class="nx">colors</span><span class="p">)</span><span class="c1">//'red,blue,green'</span>
  <span class="nx">subtype2</span><span class="p">.</span><span class="nx">getName</span><span class="p">()</span> <span class="c1">//'Soul'</span>
  <span class="nx">subtype2</span><span class="p">.</span><span class="nx">getAge</span><span class="p">()</span> <span class="c1">//24</span></code></pre></figure>

<blockquote>
  <p>总结：避免了原型链和借用构造函数的缺陷，是JavaScript最常用的继承方式。
缺点：无论什么情况，都会调用2次超类的构造函数。一次是：创造子类型原型时，另一次是：在子类型构造函数内部。
instanceof 和  isPrototypeOf()都有效。</p>
</blockquote>

<blockquote>
  <p>instanceof 和 isPrototypeOf() 都是用来确定对象之间是否存在关系。使用方式：</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js"> <span class="nx">obj</span> <span class="c1">//实例</span>
 <span class="nb">Object</span> <span class="c1">//构造函数</span>
 <span class="nx">obj</span> <span class="k">instanceof</span> <span class="nb">Object</span>
 <span class="nb">Object</span><span class="p">.</span><span class="nx">isPrototypeOf</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span></code></pre></figure>

<blockquote>
  <h3 id="section-4">4.原型式继承</h3>
  <p>基本思想：借助原型可以基于已有对象创建新对象，同时还不必创建自定义类型。 —道格拉斯.克罗克福德</p>
</blockquote>

<blockquote>
  <p>函数如下：</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">  <span class="kd">function</span> <span class="nx">object</span><span class="p">(</span><span class="nx">o</span><span class="p">){</span>
    <span class="kd">function</span> <span class="nx">F</span><span class="p">(){}</span>
    <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">o</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">F</span><span class="p">()</span>
  <span class="p">}</span></code></pre></figure>

<blockquote>
  <p>在object()函数的内部创建一个临时的构造函数,然后将传人的对象作为这个构造函数的原型，最后返回这个临时类型的实例。
object()对传进来的对象执行一次浅复制。</p>
</blockquote>

<blockquote>
  <h4 id="section-5">4.1 浅复制与深复制</h4>
  <p>浅复制：将一个对象或数组赋予其他变量，那么我们只要更改其中的任何一个，然后其他的也会跟着改变。</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="s1">'Jin'</span><span class="p">}</span>
  <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s1">'Soul'</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span><span class="nx">b</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span> <span class="c1">//'Soul','Soul'</span></code></pre></figure>

<blockquote>
  <p>这是因为他们引用的都是同一个对象。</p>
</blockquote>

<blockquote>
  <p>深复制：就是把对象的属性遍历一遍，赋给一个新的对象。</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="s1">'Jin'</span><span class="p">}</span>
  <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">{</span><span class="na">name</span> <span class="p">:</span> <span class="nx">a</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s1">'Soul'</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span><span class="nx">b</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span> <span class="c1">//'Jin','Soul'</span></code></pre></figure>

<blockquote>
  <p>总之：浅拷贝就是两个变量使用同一对象，深拷贝就是两个不同对象</p>
</blockquote>

<blockquote>
  <p>回归正题,看案例：</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">  <span class="kd">function</span> <span class="nx">object</span><span class="p">(</span><span class="nx">o</span><span class="p">){</span>
    <span class="kd">function</span> <span class="nx">F</span><span class="p">(){}</span>
    <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">o</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">F</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span> <span class="p">:</span> <span class="s1">'Jin'</span><span class="p">,</span>
    <span class="na">friends</span> <span class="p">:</span> <span class="p">[</span><span class="s1">'aaa'</span><span class="p">,</span><span class="s1">'bbb'</span><span class="p">,</span><span class="s1">'ccc'</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">aperson</span> <span class="o">=</span> <span class="nx">object</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
  <span class="nx">aperson</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s1">'Soul'</span>
  <span class="nx">aperson</span><span class="p">.</span><span class="nx">friends</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">'ddd'</span><span class="p">)</span>
  
  <span class="kd">var</span> <span class="nx">bperson</span> <span class="o">=</span> <span class="nx">object</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
  <span class="nx">bperson</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s1">'Yim'</span>
  <span class="nx">bperson</span><span class="p">.</span><span class="nx">friends</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">'eee'</span><span class="p">)</span>
  
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">friends</span><span class="p">)</span><span class="c1">//'aaa,bbb,ccc,ddd,eee'</span></code></pre></figure>

<blockquote>
  <p>也可以使用 <em>Object.create(person)</em> 代替  <em>object(person)</em></p>
</blockquote>

<blockquote>
  <p>Object.create() 支持情况 : IE 9+ ,Firefox 4+ ,Safari 5+ , Opera 12+ , chrome</p>
</blockquote>

<blockquote>
  <p>总结：在没有必要兴师动众的创建构造函数，而只是想让一个对象与另一个对象保持类似的情况下，就可以使用原型式继承。
缺点：包含共享属性。</p>
</blockquote>

<blockquote>
  <h3 id="section-6">5.寄生式继承</h3>
  <p>寄生式继承和原型式继承都是由道格拉斯-克罗克福德推广的。基本思想就是创建一个仅用于封装继承过程的函数，
该函数在内部以某种方式增强对象，最后再像真的是对它做了所有工作一样返回对象。</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">  <span class="kd">function</span> <span class="nx">object</span><span class="p">(</span><span class="nx">o</span><span class="p">){</span>
    <span class="kd">function</span> <span class="nx">F</span><span class="p">(){}</span>
    <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">o</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">F</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">create</span><span class="p">(</span><span class="nx">obj</span><span class="p">){</span>
   <span class="kd">var</span> <span class="nx">clone</span> <span class="o">=</span> <span class="nx">object</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
   <span class="nx">clone</span><span class="p">.</span><span class="nx">sayHi</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Hi'</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">clone</span> 
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span> <span class="p">:</span> <span class="s1">'Jin'</span><span class="p">,</span>
    <span class="na">friends</span> <span class="p">:</span> <span class="p">[</span><span class="s1">'aaa'</span><span class="p">,</span><span class="s1">'bbb'</span><span class="p">,</span><span class="s1">'ccc'</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">aperson</span> <span class="o">=</span> <span class="nx">create</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
  <span class="nx">aperson</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">()</span><span class="c1">//'Hi'</span></code></pre></figure>

<blockquote>
  <p>总结：在主要考虑对象而不是自定义类型和构造函数的情况下可以考虑使用。</p>
</blockquote>

<blockquote>
  <h3 id="section-7">6.寄生组合式继承</h3>
  <p>即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。基本思想：
不必为了指定子类型的原型而调用超类型的构造函数，我们需要的只是超类型原型的一个副本而已。
本质上，就是使用寄生式的继承来继承超类的原型，而后再将结果指定给予子类型的原型。</p>
</blockquote>

<figure class="highlight"><pre><code class="language-js" data-lang="js">  <span class="kd">function</span> <span class="nx">object</span><span class="p">(</span><span class="nx">o</span><span class="p">){</span>
    <span class="kd">function</span> <span class="nx">F</span><span class="p">(){}</span>
    <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">o</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">F</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">inheritPrototype</span><span class="p">(</span><span class="nx">subtype</span><span class="p">,</span><span class="nx">supertype</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">prototype</span> <span class="o">=</span> <span class="nx">object</span><span class="p">(</span><span class="nx">supertype</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span>
    <span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">subtype</span>
    <span class="nx">subtype</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">prototype</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">SuperType</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'red'</span><span class="p">,</span><span class="s1">'blue'</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="nx">SuperType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  	<span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">SubType</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">age</span><span class="p">){</span>
    <span class="nx">SuperType</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="nx">name</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span> 
  <span class="p">}</span>
  <span class="nx">inheritPrototype</span><span class="p">(</span><span class="nx">SubType</span> <span class="p">,</span> <span class="nx">SuperType</span><span class="p">)</span>
  <span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getAge</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">age</span>
  <span class="p">}</span></code></pre></figure>

<blockquote>
  <p>最理想的引用类型继承模式。</p>
</blockquote>

</div>
						</div>
				</div>
			</div>
			<div class="j-col-xs-12 j-col-sm-12 j-col-md-3">
	<div class="j-user">
		<div class="j-user-thumb">
			<a href="/blog/me.html"><img src="/blog/images/user.jpg" alt="" /></a>
		</div>
		<div class="j-user-info">
			<a href="/blog/me.html">微信</a>
			<a href="/blog/me.html">微博</a>
			<a href="/blog/me.html">QQ</a>
		</div>
	</div>
	<div class="j-class-list">
		<h3 class="j-row">分类</h3>
		
		<a href="/blog/category.html?category=笔记">笔记 <span class="j-class-i-num">(12)</span></a>
		
		<a href="/blog/category.html?category=JavaScript">JavaScript <span class="j-class-i-num">(10)</span></a>
		
		<a href="/blog/category.html?category=bee.js">bee.js <span class="j-class-i-num">(1)</span></a>
		
		<a href="/blog/category.html?category=Promise">Promise <span class="j-class-i-num">(3)</span></a>
		
	</div>
</div>
		</div>
	</div>
	<div class="j-container-fluid j-footer">
	<div class="j-container">
		<p class="j-footer-say">喜欢一个人需要理由吗？需要吗？不需要吗？需要吗？……</p>
		<p class="j-footer-say j-tlgr">——周星驰 《大话西游》</p>
	</div>
</div>

</body>
</html>